#define ERRO 		0
#define OK 		 	1
#define IGUAL 		10
#define DIF		 	11

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <string.h>

// estrutura de um elemento, no da arvore
struct sNo {
	int valor, freq;
	char carcter;
	struct sNo *esq;
	struct sNo *dir;
};

typedef struct sNo sNo;

sNo *inicializa();
sNo *cria(int valor, int freq, char caracter, sNo *sae, sNo *sad, int *res);


int e_vazia(sNo *a);
int busca(int valor, sNo *a);

void imprime_pre_order(sNo *a);
void imprime_in_order(sNo *a);
void imprime_pos_order(sNo *a);
void imprime_textual(sNo *a);
int checkVetor(char c, struct sNo *vetor);
void printVetor(struct sNo *vetor);
void inicilizaVetor(struct sNo *vetor);
void ordenaVetor(struct sNo *vetor);

int altura(sNo *a);
int qtdeNos(sNo *a);
int qtdeFolhas(sNo *a);

int main(int argc,char *argv[])
{
	//TODO: add usage output
    char *command,*filename,*compressfilename;
    if(argc>1)
    {
        command = argv[1];
        filename = argv[2];
        compressfilename = argv[3];
    }else
    {
    	cout << "Modo de Uso: " << endl;
    	cout << "Para comprimir:\n$huffmancoding -c doNomeArquivo comp_nomearquivo\n" << endl;
    	cout << "Para descomprimir:\n$huffmancoding -d paraNomeAquivo comp_nomearquivo \n" << endl;
    }

    Arvore ht = Arvore();
    if(!strcmp(command,"-c"))
        ht.compress(filename,compressfilename);

    if(!strcmp(command,"-d"))
        ht.decompress(compressfilename,filename);
    return 0;
}
sNo *inicializa(void) {
	return NULL;
}
// 2) eh composta por uma raiz e duas subarvores (esquerda e direita)
sNo *cria(int valor, int freq, char caracter, sNo *sae, sNo *sad, int *res) {
	sNo *no;
	no = (sNo *)malloc(sizeof(sNo));
	if (no == NULL) *res = ERRO;
	else {
		no->esq = sae;
		no->dir = sad;
		no->valor = valor;
		no->carcter = caracter;
		no->freq = freq;
		*res = OK;
	}
	return no;
}

// verifica se arvore a eh vazia
int e_vazia(sNo *a) {
	return a == NULL;
}

// indica ocorrencia ou nao do valor na arvore
int busca(int valor, sNo *a) {
	if (e_vazia(a))
		return 0;
	else // encontra ou busca a esquerda ou busca a direita, interrompe assim que achar
		return a->valor == valor || busca(valor, a->esq) || busca(valor, a->dir);
}

// impressao dos nos da arvore:
//    -> pre-order/pré-ordem: trata raiz, percorre sae, percorre sad
//    -> in-order/ordem simétrica: percorre sae, trata raiz, percorre sad
//    -> pos-order/pós-ordem: percorre sae, percorre sad, trata raiz
void imprime_pre_order(sNo *a) {
	if (!e_vazia(a)) {
		printf("%d", a->valor);
		if (a->carcter != NULL) {
			printf("%c", a->carcter);
		}
		else
			printf(" ");
		imprime_pre_order(a->esq);
		printf(" ");
		imprime_pre_order(a->dir);
		printf(" ");
	}
}

void imprime_in_order(sNo *a) {
	if (!e_vazia(a)) {
		imprime_in_order(a->esq);
		printf(" %d ", a->valor);
		imprime_in_order(a->dir);
	}
}

// representacao textual, percurso eh pre-order
void imprime_textual(sNo *a) {
	if (e_vazia(a))
		printf("<>");
	else {
		printf("<%d", a->valor);
		imprime_textual(a->esq);
		imprime_textual(a->dir);
		printf(">");
	}
}

// retorna a altura da arvore
int altura(sNo *a) {
	int ae, ad;

	if (a == NULL)
		return -1; // arvore vazia tem altura -1 
	else if (a->esq == NULL && a->dir == NULL)
		return 0; // arvore com apenas raiz tem altura 0
	else {
		ae = altura(a->esq);
		ad = altura(a->dir);
		if (ae > ad)
			return 1 + ae;
		else
			return 1 + ad;
	}
}

// retorna a quantidade de nos da arvore
int qtdeNos(sNo *a) {
	if (a == NULL)
		return 0;
	else
		return 1 + qtdeNos(a->esq) + qtdeNos(a->dir);
}

// retorna a quantidade de folhas (nos sem filhos) da arvore
int qtdeFolhas(sNo *a) {
	if (a == NULL)
		return 0;
	if (a->esq == NULL && a->dir == NULL)
		return 1;
	return qtdeFolhas(a->esq) + qtdeFolhas(a->dir);
}

int checkVetor(char c, struct sNo *vetor) {

	for (int j = 0; j < 255; j++) {
		if (c == (vetor + j)->carcter) {
			return IGUAL;
		}

	}
	return DIF;
}

void printVetor(struct sNo *vetor) {
	printf("Simbolos:\n");
	for (int l = 0; l < 255; l++) {
		if ((vetor + l)->carcter == NULL && (vetor + l)->dir == NULL && (vetor + l)->esq == NULL && (vetor + l)->freq == NULL && (vetor + l)->valor == NULL) {

		}
		else
		{
			
			printf("caracter %c: %d\n", (vetor + l)->carcter, (vetor + l)->freq);
		}
	}

}

void inicilizaVetor(struct sNo *vetor) {
	for (int t = 0; t < 255; t++) {
		(vetor + t)->carcter = NULL;
		(vetor + t)->dir = NULL;
		(vetor + t)->esq = NULL;
		(vetor + t)->freq = NULL;
		(vetor + t)->valor = NULL;
	}

}

void ordenaVetor(struct sNo *vetor) {
	for (int l = 0; l < 255; l++) {
		if ((vetor + l)->carcter == NULL && (vetor + l)->dir == NULL && (vetor + l)->esq == NULL && (vetor + l)->freq == NULL && (vetor + l)->valor == NULL) {

		}
		else
		{
			int p;
			struct sNo aux2;

			for (int d = 1; d < 255; d++) {
				aux2 = vetor[d];
				p = d - 1;
				while (p >= 0 && (vetor + p)->freq < aux2.freq) {
					vetor[p + 1] = vetor[p];
					p--;
				}
				vetor[p + 1] = aux2;
			}
		}
	}
}
